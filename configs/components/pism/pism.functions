#!/usr/bin/ksh

# Functions for pism and pism-mpiesm run scripts -- pism part

pism_set_defaults() {
    # PG: Define some coupling variables
    MY_COMMAND_FLAGS_pism=${MY_COMMAND_FLAGS_pism:-""}
    check_pism_command_for_duplicates=${check_pism_command_for_duplicates:-1}
    default_pism_config_file=$(find $MODEL_DIR_pism -name pism_config.nc)
    pism_config_file=${pism_config_file:-${default_pism_config_file}}

    #mecho pism_resolution
    #pism_resolution

    # PG: TODO: This needs to have a LD_LIB Path
    export LD_LIBRARY_PATH="${MODEL_DIR_pism}/lib/:$LD_LIBRARY_PATH"
}


pism_set_directory_paths() {
    TS_FILE_NAME_pism=${EXP_ID}_pismr_timeseries_${CURRENT_YEAR_pism}-${END_YEAR_pism}.nc
    EX_FILE_NAME_pism=${EXP_ID}_pismr_extra_${CURRENT_YEAR_pism}-${END_YEAR_pism}.nc
    OUTPUT_FILE_NAME_pism=${EXP_ID}_pismr_out_${CURRENT_YEAR_pism}-${END_YEAR_pism}.nc

    mecho pism_set_input_file
    pism_set_input_file
}

pism_protocol() {
    case ${PROTOCOL_pism} in
	"ISMIP6")
	    TS_VARS_pism=${TS_VARS_pism:-"ice_mass,limnsw,tendency_of_ice_mass_due_to_basal_mass_flux,tendency_of_ice_mass_due_to_discharge,tendency_of_ice_mass_due_to_surface_mass_flux"}
	    EX_INTERVAL_pism=${EX_INTERVAL_pism:-monthly}
	    EX_VARS_pism=${EX_VARS_pism:-"climatic_mass_balance,ice_surface_temp,sftflf,sftgrf,shelfbtemp,surface_accumulation_flux,surface_melt_fux,surface_runoff_flux,tempbase,thk,topg,usurf,velbar,velbase,velsurf,wvelbase,wvelsurf"}
	    ;;
	*)
	    echo "#=============================================="
	    echo "#"
	    echo "#   UNKNOWN protocol : >>${PROTOCOL_pism}<<"
	    echo "#"
	    echo "#=============================================="
    esac
}

pism_prepare_exe() {
    add_to ${BIN_DIR_pism}/${EXE_pism} ${EXE_pism}
    echo -e "\t\tTaking pism executable BIN_DIR_pism/EXE_pism=${BIN_DIR_pism}/${EXE_pism}"
}

pism_set_input_file() {
        if [[ $RUN_NUMBER_pism -eq 1 ]] && [[ $LRESUME_pism -eq 0 ]]; then
                INPUT_FILE_pism=${INPUT_FILE_pism:-${POOL_DIR_pism}/input/${DOMAIN_pism}/${EXE_pism}_${DOMAIN_pism}_${RES_pism}.nc}
        elif [[ ${RUN_NUMBER_pism} -eq 1 ]] && [[ ${LRESUME_pism} -eq 1 ]]; then
                if [ -z "$SPINUP_FILE_pism" ]; then
                    echo "          You must specify the SPINUP_FILE_pism"
                    exit 42
                fi
                INPUT_FILE_pism=${SPINUP_FILE_pism}
        else
                echo "RUN_NUMBER_pism=$RUN_NUMBER_pism, LRESUME_pism=$LRESUME_pism"
                INPUT_FILE_pism="$(readlink -f ${RESTART_DIR_pism}/latest_restart_file_pism.nc)"
        fi
        echo -e "\t\tTaking pism input file for this run from INPUT_FILE_pism=$INPUT_FILE_pism"
}

pism_prepare_init() {
    if [[ $RUN_NUMBER_pism -eq 1 ]] && [[ $LRESUME_pism -eq 0 ]]; then
	echo ""
        echo -e "\t\tTaking pism input file and assuming COLD START!"
        echo -e "\t\tI hope you know what you are doing..."
        echo ""
        add_to $INPUT_FILE_pism ${EXE_pism}_${DOMAIN_pism}_${RES_pism}.cold_start.nc
        IFILE_pism=${EXE_pism}_${DOMAIN_pism}_${RES_pism}.cold_start.nc
    elif [[ ${RUN_NUMBER_pism} -eq 1 ]] && [[ ${LRESUME_pism} -eq 1 ]]; then
        echo -e "\t\tTaking pism input file from your definition and assuming SPINUP START!"
        add_to $INPUT_FILE_pism ${EXE_pism}_${DOMAIN_pism}_${RES_pism}.spinup_start.nc
        IFILE_pism=${EXE_pism}_${DOMAIN_pism}_${RES_pism}.spinup_start.nc
    fi
}

pism_prepare_restart_in() {
    if [[ ! $RUN_NUMBER_pism -eq 1 ]]; then
        echo -e "\t\tTaking pism input file from newest file in RESTART_DIR_pism: ${RESTART_DIR_pism}"
        restart_file="$(readlink -f ${RESTART_DIR_pism}/latest_restart_file_pism.nc)"
        add_to $restart_file $(basename ${restart_file})
        IFILE_pism=$(basename ${restart_file})
    elif [[ ! -z $IFILE_pism ]]; then
	echo -e "\t\tINPUT_FILE_pism already defined: INPUT_FILE_pism=$IFILE_pism"
        echo -e "\t\t --OR--"
        echo -e "\t\tSPINUP_FILE_pism=$IFILE_pism (if you are doing LRESUME_pism=1)"
	echo ""
        echo -e "\t\tYou are probably doing a cold start or a start from spinup!"
    else
        echo "This should never happen..."
        exit 42
    fi
}

pism_prepare_config() {

    add_to $pism_config_file pism_config.nc

    echo "Working here: $(pwd)"
    #create header of pism_overrides.cdl
    echo "netcdf pism_overrides {" > pism_overrides.cdl
    echo "   variables:" >> pism_overrides.cdl
    echo "   byte pism_overrides;" >> pism_overrides.cdl

    ##CONFIG_OVERRIDE_FILE_pism is set -> add each line to pism_overrides
    if [[ ! -z $CONFIG_OVERRIDE_FILE_pism ]]
    then
        #Extracting the options from CONFIG_OVERRIDE_FILE_pism and re-formating it to our needs
        ncdump -h $CONFIG_OVERRIDE_FILE_pism | grep -e '^.*:.* = .*;' | grep -Eiv '(_doc|_name|_unit|_option|_type|_choices)' | sed -r 's/^.*:(.*) = (.*) ;/   pism_overrides:\1 = \2 ;/g' >> pism_overrides.cdl
    fi

    if [[ $MY_COMMAND_FLAGS_pism == *-config_override* ]]; then
        echo "Error! MY_COMMAND_FLAGS_pism contains -config_override. Add the override file name as CONFIG_OVERRIDE_FILE_pism..."
        return 1
    fi

    if [[ "x$iterative_coupling" == "x1" ]] || [[ "x${offline_index}" == "x1" ]]; then
        for couple_type in coupler config_value forcing; do
                echo "Looking for ${COUPLE_DIR}/pism_${couple_type}_${CHUNK_START_DATE_pism}-${CHUNK_END_DATE_pism}.dat"
                if [ -f ${COUPLE_DIR}/pism_${couple_type}_${CHUNK_START_DATE_pism}-${CHUNK_END_DATE_pism}.dat ]; then
                        echo "Found ${COUPLE_DIR}/pism_${couple_type}_${CHUNK_START_DATE_pism}-${CHUNK_END_DATE_pism}.dat"
                        source ${COUPLE_DIR}/pism_${couple_type}_${CHUNK_START_DATE_pism}-${CHUNK_END_DATE_pism}.dat
                else
                        echo "Could not find ${COUPLE_DIR}/pism_${couple_type}_${CHUNK_START_DATE_pism}-${CHUNK_END_DATE_pism}.dat"
                        exit 42
                fi
        done
    fi

    # pism_set_coupler___atmosphere
    searchname="pism_set_coupler"
    list_of_all_vars=`set | awk -v pat="${searchname}" ' BEGIN { FS = "=" } ; $1 ~ pat {print $1}'`
    for variable in $list_of_all_vars; do
        arrIN=(${variable//___/ })
        unset arrIN[0]
        option=$(echo ${arrIN[*]} | sed 's+ +.+g')
        eval value=\"\$$variable\"
        case "$option" in
                atmosphere|surface|ocean|sea_level)
                        echo "Setting standard pism $option to $value"
                        ;;
                ocean_o3d*|lake_level)
                        echo "Setting local pism $option to $value"
                        ;;
                * )
                        echo "Unknown coupler: $option"
                        exit 42
                        ;;
        esac
        pism_set_config_value ${option// /} "${value}" "force"
    done

    searchname="pism_set_config_value"
    list_of_all_vars=`set | awk -v pat="${searchname}" ' BEGIN { FS = "=" } ; $1 ~ pat {print $1}'`
    for variable in $list_of_all_vars; do
        arrIN=(${variable//___/ })
        force=${arrIN[0]##*_}
        if [[ $force == "FORCE" ]]; then
            force="force"
        else
            force=""
        fi
        unset arrIN[0]
        option=$(echo ${arrIN[*]} | sed 's+ +.+g')
        eval value=\"\$$variable\"
        pism_set_config_value ${option// /} "${value}" ${force// /}
    done

    searchname="pism_set_flag"
    list_of_all_vars=`set | awk -v pat="${searchname}" ' BEGIN { FS = "=" } ; $1 ~ pat {print $1}'`
    for variable in $list_of_all_vars; do
        arrIN=(${variable//___/ })
        unset arrIN[0]
        option=$(echo ${arrIN[*]} | sed 's+ +.+g')
        eval value=\"\$$variable\"
        value_uc=`echo $value | tr a-z A-Z`
        case "$value_uc" in
                NO|OFF|FALSE|0)
                        echo "Flag -${option} unset (value was ${value})"
                        ;;
                * )
                        echo "Flag -${option} set (value was ${value})"
                        pism_set_config_value ${option// /} "___FLAG___" "force"
                        ;;
        esac
    done

    #create footer of pism_overrides.cdl
    echo "}" >> pism_overrides.cdl

    #compile and add override file
    ncgen pism_overrides.cdl -o pism_overrides.nc
    add_to ./pism_overrides.nc pism_overrides.nc
    CONFIG_COMMAND_LINE_OPTS_pism=" -config_override pism_overrides.nc $CONFIG_COMMAND_LINE_OPTS_pism "
}

pism_prepare_forcing() {
    if [[ "x$iterative_coupling" = "x1" ]]; then
        mecho "Looking for ${COUPLE_DIR}/pism_forcing_${CHUNK_START_DATE_pism}-${CHUNK_END_DATE_pism}.dat"
        source ${COUPLE_DIR}/pism_forcing_${CHUNK_START_DATE_pism}-${CHUNK_END_DATE_pism}.dat
    fi

    searchname="pism_set_forcing_file"
    list_of_all_vars=`set | awk -v pat="${searchname}" ' BEGIN { FS = "=" } ; $1 ~ pat {print $1}'`
    for variable in $list_of_all_vars; do
        arrIN=(${variable//___/ })
        unset arrIN[0]
        forcing_type=$(echo ${arrIN[*]} | sed 's+ +.+g')
        eval path=\"\$$variable\"
        echo "Calling add_to $path $(basename ${path})"
        add_to ${path} $(basename ${path})
        pism_set_forcing_file ${forcing_type} $(basename ${path})
    done

    if [[ "x$offline_index" = "x1" ]]; then
           echo "PG: Running offline index routine"

           previous_working_directory=$(pwd)
           # Set up a fake COUPLE_DIR to work in:
           OLD_COUPLE_DIR=$COUPLE_DIR
           echo "Making a fake COUPLE_DIR to work in here: $(pwd)/fake_couple"
           mkdir -p fake_couple
           COUPLE_DIR=$(pwd)/fake_couple
           cd $COUPLE_DIR

           index_file=${index_file:-${FUNCTION_PATH}/index.dat}
           echo "Index File: $index_file"
           echo "Index values at $RUN_NUMBER_pism"
           index_values=$(sed "${RUN_NUMBER_pism}q;d" $index_file)
           echo $index_values | read kyr index
           index_script=${index_script:-${FUNCTION_PATH}/pism_index_script.py}

           echo "Using PI_file=$PI_file"
           echo "Using LGM_file=$LGM_file"
           echo "Using index=$index"
           echo "Using kyr=$kyr"
           echo "python ${index_script} $PI_file $LGM_file $index $kyr ${COUPLE_DIR}/dummy_atmosphere.nc"

           python ${index_script} $PI_file $LGM_file $index $kyr ${COUPLE_DIR}/dummy_atmosphere.nc
           cdo -f nc -t echam6 \
                -expr,"orog=geosp/9.81; aprt=aprl+aprc; temp2=temp2; swd=srads-sradsu; lwd=trads-tradsu; cc=aclcov" \
                -selcode,167,143,142,129,176,204,177,205,164 \
                ${COUPLE_DIR}/dummy_atmosphere.nc \
                ${COUPLE_DIR}/atmosphere_file_for_ice.nc
           ls -ratlh ${COUPLE_DIR}/atmosphere_file_for_ice.nc
           cdo pardes ${COUPLE_DIR}/atmosphere_file_for_ice.nc
           iterative_coupling_echam6_ice_write_names

           atmosphere2pism

           cd -
           echo "----------------------------- PG ----------------------------------"
           pwd
           ls -ratl
           echo "###################################################################"
           ls -ratl $COUPLE_DIR
           echo "----------------------------- PG ----------------------------------"

           case $iterative_coupling_atmosphere_pism_ablation_method in
                   "PDD")
                           # Bad Hack: Just move the thing to the forcing folder with the correct dates
                           mv ${COUPLE_DIR}/atmo_given_file_-.nc ${FORCING_DIR_pism}/atmo_given_file_${START_DATE_pism}-${END_DATE_pism}.nc
                           # NOTE: this might need to be add_to instead...?
                           pism_set_forcing_file atmosphere_given ${FORCING_DIR_pism}/atmo_given_file_${START_DATE_pism}-${END_DATE_pism}.nc
                           ;;
                   "DEBM")
                           # Bad Hack: Just move the thing to the forcing folder with the correct dates
                           mv ${COUPLE_DIR}/surface_given_file_-.nc ${FORCING_DIR_pism}/surface_given_file_${START_DATE_pism}-${END_DATE_pism}.nc
                           # NOTE: this might need to be add_to instead...?
                           pism_set_forcing_file surface_given ${FORCING_DIR_pism}/surface_given_file_${START_DATE_pism}-${END_DATE_pism}.nc
                           ;;

                   *)
                           echo "Offline index coupling only works with PDD and DEBM for now!"
                           echo "Unknown option: iterative_coupling_atmosphere_pism_ablation_method=${iterative_coupling_atmosphere_pism_ablation_method}"
           esac
           # And go back to the previous working directory:
           cd ${previous_working_directory}
    fi
}

pism_modify_forcing() {
    if [[ $ATMO_FORCING_FROM_RAW_GCM_pism -eq 1 ]]; then
        pism_helpers_interpolate_atmo_forcing
    fi

    if [[ $OCEAN_FORCING_FROM_RAW_GCM_pism -eq 1 ]]; then
        echo "PG: Not yet implemented..."
        echo "exiting"
        exit 42
    fi
}

pism_cleanup() {
    add_to ${WORK_DIR}/${TS_FILE_NAME_pism} latest_ts_file_pism.nc output
    add_to ${WORK_DIR}/${EX_FILE_NAME_pism} latest_ex_file_pism.nc output
    add_to ${WORK_DIR}/${OUTPUT_FILE_NAME_pism} latest_restart_file_pism.nc restart_out
}

pism_set_forcing_file() {

    mecho "PG: Calling pism_set_forcing_file..."
    forcing_type=$1
    path=$2

    mecho "$forcing_type"
    mecho "$path"

    FORCING_FILE_pism="-${forcing_type}_file ${path}"
    FORCING_COMMAND_LINE_OPTS_pism="${FORCING_COMMAND_LINE_OPTS_pism} ${FORCING_FILE_pism}"
}

pism_set_config_value() {
    option=$1
    value=$2
    force=$3

    if [[ $value = "___FLAG___" ]]; then
        value=""
    fi

    error=1
    # Check if the user gave the short option:
    if $(ncdump -h $pism_config_file | grep -q "pism_config:.*_option = \"${option}\""); then
        #Retrieve the long option from config file, which might be needed for the override file
        option_long=$(ncdump -h $pism_config_file | grep  "pism_config:.*_option = \"${option}\"" |  sed -r "s/^.*pism_config:(.*)_option = ?\"$option?\" ;/\1/g")
        error=0
    fi

    #Check if a short option exists
    if $(ncdump -h $pism_config_file | grep -q "pism_config:${option}_option") && [[ $error -eq 1 ]]; then
        #Given option is a valid 'long' PISM option. Keep this option because it might be needed for the override file and set option to the 'short' version
        option_long=$option
        option=$(ncdump -h ${pism_config_file} | grep "pism_config:${option}_option" | cut -d= -f2 | cut -d\" -f2)
        error=0
    fi

    if [[ $error -eq 1 ]]; then
        if $(ncdump -h $pism_config_file | grep -q "pism_config:${option}") || [[ ! -z $force ]]; then
            #'Long' option given and no short option available (or the option should be forced).
            option_long=$option
            error=0
        fi
    fi

    if [[ $error -eq 1 ]]; then
        echo "${option} not found in $pism_config_file"
        echo "If you REALLY want to do this, use:"
        echo "pism_set_config_value_FORCE___$option=$value"
        echo "exiting..."
        exit 42
    fi

    if [[ ! -z $force ]]; then
        #Option that needs to be forced -> write to command line options

        #Add "" if value contains spaces
        if $(echo $value | grep -q "[[:space:]]")
        then
            value=\"${value}\"
        fi

        CONFIG_COMMAND_LINE_OPTS_pism="$CONFIG_COMMAND_LINE_OPTS_pism -${option} ${value} "
    else
        ##Option is known -> add to override file
        #Check if value is a number, if not add ""
        if [[ $(awk -v a="${value}" 'BEGIN {print (a == a + 0)}';) == 0 ]] ; then
            value=\"${value}\"
        fi

        #Check if option is already in pism_overrides.cdl
        if $(cat pism_overrides.cdl | grep -q "${option_long}"); then
            echo "Error! Option \"${option_long}\" already set before!"
            return 1
        fi

        echo "   pism_overrides:${option_long} = ${value} ;" >> pism_overrides.cdl
    fi
}

pism_check_errors() {
        if grep -q "ERROR" ${SCRIPT_DIR}/${EXP_ID}_${THIS_JOB_ID}.log; then
                echo "!!! DETECTED ERROR !!!"
                echo "General Problem with pism >> PISM ERROR << has occured. Killing your job. Sorry." >> $error_log
                return 84
        fi
}

pism_post_process() {
    #mecho "Empty post process function for iterative coupling"
    mecho "Post process function for iterative coupling (check if output file exists)"
    if [ -f ${RESTART_DIR_pism}/$OUTPUT_FILE_NAME_pism ] ; then
	mecho "Found restart/output file ${OUTPUT_FILE_NAME_pism}"
    else
	mecho "MISSING restart/output file ${OUTPUT_FILE_NAME_pism}"
	echo ; echo " ****** Missing restart/output file ${OUTPUT_FILE_NAME_pism} ******" ; echo
    fi
}

pism_before_first_run_in_chunk() {
        iter_coup_regrid_method_atm2ice=${iter_coup_regrid_method_atm2ice:-DOWNSCALE}   # Atmosphere
        iter_coup_ablation_method_atm2ice=${iter_coup_ablation_method_atm2ice:-PDD}
        iter_coup_regrid_method_oce2ice=${iter_coup_regrid_method_oce2ice:-EXTRAPOLATE} # Ocean
        iter_coup_interact_method_oce2ice=${iter_coup_interact_method_oce2ice:-OCEANTEMPSALT}

        DOWNSCALING_LAPSE_RATE=${DOWNSCALING_LAPSE_RATE:--0.007}
        ATMOSPHERE_TO_PISM=${ATMOSPHERE_TO_PISM:-1}
        OCEAN_TO_PISM=${OCEAN_TO_PISM:-1}
        # PG: Coupling: Ensure that PISM wants to recieve and that the ACM actually sent information:
        if [ "x${ATMOSPHERE_TO_PISM}" == "x1" ]; then
                atmosphere2pism
        fi
        if [ "x${OCEAN_TO_PISM}" == "x1" ]; then
                ocean2pism
        fi
}

pism_after_last_run_in_chunk() {
        iter_coup_regrid_method_ice2oce=${iter_coup_regrid_method_ice2oce:-EXTRAPOLATE} # Ocean
        iter_coup_interact_method_ice2oce=${iter_coup_interact_method_ice2oce:-BASALSHELF_WATER_ICEBERG_WATER}

        PISM_TO_ATMOSPHERE=${PISM_TO_ATMOSPHERE:-1}
        if [ "x${PISM_TO_ATMOSPHERE}" == "x1" ]; then
                pism2atmosphere
        fi
        PISM_TO_OCEAN=${PISM_TO_OCEAN:-1}
        if [ "x${PISM_TO_OCEAN}" == "x1" ]; then
                pism2ocean
        fi
}

pism_set_execution_command() {
    mecho "All options set for run with: "
    mecho "expid: $EXP_ID"


    if [[ "x$TS_VARS_pism" == "x" ]]; then
            TS_VARS_OPTS_pism=""
            # NOTE: This is equivalent to using ALL variables"
    else
            TS_VARS_OPTS_pism="-ts_vars $TS_VARS_pism"
    fi

    case "$CALTYPE_pism" in
            0)
                    echo "No leap (365_day) calendar"
                    echo "Using the 365_day calendar, PISM ignores the reference date given in the time unit of all input files."
                    echo "Make sure that this reference year is consistent throughout the input files (such as 'since 1950-01-01')"
                    echo "and matches the reference year used to specify the simulation time of PISM."
                    echo "It is recommended to also specify this reference date using '-time.reference_date'. This only causes the"
                    echo "units argument of time axis in the PISM output files to be 'seconds since ...' reference date."
                    echo "If not set PISM assumes 1-1-1 as reference year."

                    CAL_OPTS_pism=""
                    YS_OPTS_pism=$CURRENT_YEAR_pism
                    ;;
            30)
                    echo "360_day calendar"
                    echo "Using the 360_day calendar, PISM ignores the reference date given in the time unit of all input files."
                    echo "Make sure that this reference year is consistent throughout the input files (such as 'since 1950-01-01')"
                    echo "and matches the reference year used to specify the simulation time of PISM."
                    echo "It is recommended to also specify this reference date using '-time.reference_date'. This only causes the"
                    echo "units argument of time axis in the PISM output files to be 'seconds since ...' reference date."
                    echo "If not set PISM assumes 1-1-1 as reference year."

                    CAL_OPTS_pism="-calendar 360_day"
                    YS_OPTS_pism=$CURRENT_YEAR_pism
                    ;;
            1)
                    echo "Proleptic gregorian calendar"
                    echo "Using the proleptic_gregorian calendar, PISM uses the reference date given in the input files to match the"
                    echo "model and data time axes."
                    echo "It is recommended to specify a reference date using '-time.reference_date ...'. This specifies the internal"
                    echo "reference date used by PISM. The time axis of the output files is in units 'seconds since ...' reference date."
                    echo "If not set PISM assumes 1-1-1 as reference year."
                    echo "NOTE: If this calendar is set, PISM will not handle periodic forcing data correctly!"

                    CAL_OPTS_pism="-calendar proleptic_gregorian"
                    YS_OPTS_pism=$(${FUNCTION_PATH}/format_date  -f1 -- ${START_DATE_pism}_ )
                    ;;
            * )
                    echo "Unsupported calendar: $CALTYPE_pism"
                    exit 42
                    ;;
    esac

    pism_execution_command="-i ${IFILE_pism} \
     $BOOTSTRAP_OPT_pism \
     $RESOLUTION_OPT_pism \
     -ys $YS_OPTS_pism -y $NYEAR_pism $CAL_OPTS_pism \
     ${CONFIG_COMMAND_LINE_OPTS_pism} ${FORCING_COMMAND_LINE_OPTS_pism}\
     -ts_file $TS_FILE_NAME_pism -ts_times ${CURRENT_YEAR_pism}:${TS_INTERVAL_pism}:$(echo "$END_YEAR_pism + 1" | bc) ${TS_VARS_OPTS_pism}\
     -extra_file $EX_FILE_NAME_pism -extra_times ${CURRENT_YEAR_pism}:${EX_INTERVAL_pism}:$(echo "$END_YEAR_pism + 1" | bc) -extra_vars $EX_VARS_pism \
     -o $OUTPUT_FILE_NAME_pism -o_size ${OUTPUT_SIZE_pism} ${MY_COMMAND_FLAGS_pism}"

    mecho $pism_execution_command
    # Lastly, check if the pism_execute command has double entires
    if [[ $check_pism_command_for_duplicates -ne 0 ]]; then
    for option in $pism_execution_command; do
        if [[ "$(echo $option | head -c 1)" == "-" ]] && [[ "$(echo $option | cut -c 2)" != +([0-9]) ]]; then
            number_of_matches=$(echo $pism_execution_command | sed -e "s/ /\n/" | python -c "import sys; testlist=sys.stdin.read().split(); print(testlist.count('$option'));")
            if [[ $number_of_matches -ne 1 ]]; then
                echo "Here's the full pism_command you want to use: $pism_execution_command"
                echo ""
                echo "It looks like you have the option $option more than once, exiting..."
                exit 42
            fi
        fi
    done
    fi

    if [ "$(echo $pism_execution_command | wc -w)" -gt "127" ]; then
        echo "Error: Maximum word length of SLURM hostfile arguments exeeded! Every word after the 127th word will be ignored..."
        echo "Exiting ..."
        return 99
    fi

    pism_execution_command=$(echo $pism_execution_command | tr -s ' ')
    COMMAND_pism="./pismr $pism_execution_command"
}
